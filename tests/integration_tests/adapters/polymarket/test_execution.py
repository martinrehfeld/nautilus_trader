# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2026 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import pkgutil
from datetime import UTC
from datetime import datetime
from unittest.mock import AsyncMock
from unittest.mock import MagicMock
from unittest.mock import Mock
from unittest.mock import patch

import msgspec
import pytest
from py_clob_client.client import ClobClient

from nautilus_trader.adapters.polymarket.common.cache import get_polymarket_trades_key
from nautilus_trader.adapters.polymarket.common.constants import POLYMARKET_VENUE
from nautilus_trader.adapters.polymarket.common.credentials import PolymarketWebSocketAuth
from nautilus_trader.adapters.polymarket.common.enums import PolymarketTradeStatus
from nautilus_trader.adapters.polymarket.common.symbol import get_polymarket_instrument_id
from nautilus_trader.adapters.polymarket.config import PolymarketExecClientConfig
from nautilus_trader.adapters.polymarket.execution import PolymarketExecutionClient
from nautilus_trader.adapters.polymarket.http.conversion import convert_tif_to_polymarket_order_type
from nautilus_trader.adapters.polymarket.providers import PolymarketInstrumentProvider
from nautilus_trader.common.component import LiveClock
from nautilus_trader.common.component import MessageBus
from nautilus_trader.core.uuid import UUID4
from nautilus_trader.data.engine import DataEngine
from nautilus_trader.execution.engine import ExecutionEngine
from nautilus_trader.execution.messages import GenerateFillReports
from nautilus_trader.execution.messages import SubmitOrder
from nautilus_trader.execution.reports import FillReport
from nautilus_trader.model.currencies import USDC
from nautilus_trader.model.currencies import USDC_POS
from nautilus_trader.model.enums import AssetClass
from nautilus_trader.model.enums import LiquiditySide
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import OrderStatus
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import AccountId
from nautilus_trader.model.identifiers import ClientOrderId
from nautilus_trader.model.identifiers import Symbol
from nautilus_trader.model.identifiers import TradeId
from nautilus_trader.model.identifiers import VenueOrderId
from nautilus_trader.model.instruments import BinaryOption
from nautilus_trader.model.objects import AccountBalance
from nautilus_trader.model.objects import Money
from nautilus_trader.model.objects import Price
from nautilus_trader.model.objects import Quantity
from nautilus_trader.portfolio.portfolio import Portfolio
from nautilus_trader.risk.engine import RiskEngine
from nautilus_trader.test_kit.providers import TestInstrumentProvider
from nautilus_trader.test_kit.stubs.component import TestComponentStubs
from nautilus_trader.test_kit.stubs.events import TestEventStubs
from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
from nautilus_trader.trading.strategy import Strategy


# Test instrument for Polymarket
ELECTION_INSTRUMENT = TestInstrumentProvider.binary_option()


class TestPolymarketExecutionClient:
    @pytest.fixture(autouse=True)
    def setup(self, request):
        # Fixture Setup
        self.loop = request.getfixturevalue("event_loop")
        self.loop.set_debug(True)

        self.clock = LiveClock()
        self.trader_id = TestIdStubs.trader_id()
        self.venue = POLYMARKET_VENUE
        self.account_id = AccountId(f"{self.venue.value}-001")

        self.msgbus = MessageBus(
            trader_id=self.trader_id,
            clock=self.clock,
        )

        self.cache = TestComponentStubs.cache()

        # Mock HTTP client
        self.http_client = MagicMock(spec=ClobClient)
        self.http_client.get_address.return_value = "0xa3D82Ed56F4c68d2328Fb8c29e568Ba2cAF7d7c8"

        # Mock the creds attribute
        mock_creds = MagicMock()
        mock_creds.api_key = "test_api_key"
        self.http_client.creds = mock_creds

        # Mock instrument provider
        self.provider = MagicMock(spec=PolymarketInstrumentProvider)
        self.provider.initialize = AsyncMock()

        # Mock WebSocket auth
        self.ws_auth = MagicMock(spec=PolymarketWebSocketAuth)

        self.portfolio = Portfolio(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )

        self.data_engine = DataEngine(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )

        self.exec_engine = ExecutionEngine(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )

        self.risk_engine = RiskEngine(
            portfolio=self.portfolio,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )

        # Create execution client
        config = PolymarketExecClientConfig()
        self.exec_client = PolymarketExecutionClient(
            loop=self.loop,
            http_client=self.http_client,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
            instrument_provider=self.provider,
            ws_auth=self.ws_auth,
            config=config,
            name=None,
        )

        # Prevent actual WebSocket connections in tests
        mock_ws_client = MagicMock()
        mock_ws_client.is_disconnected.return_value = False
        mock_ws_client.is_connected.return_value = True
        mock_ws_client.has_subscriptions = True
        mock_ws_client.subscriptions = []
        mock_ws_client.market_subscriptions.return_value = []
        mock_ws_client.connect = AsyncMock()
        mock_ws_client.disconnect = AsyncMock()
        mock_ws_client.subscribe = AsyncMock()
        mock_ws_client.unsubscribe = AsyncMock()
        mock_ws_client.add_subscription = MagicMock()
        self.exec_client._ws_client = mock_ws_client

        self.exec_engine.register_client(self.exec_client)

        self.strategy = Strategy()
        self.strategy.register(
            trader_id=self.trader_id,
            portfolio=self.portfolio,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )

        # Add test instrument to cache
        self.cache.add_instrument(ELECTION_INSTRUMENT)

        # Add instruments that match the websocket messages for testing
        # From order_placement.json and order_cancel.json
        instrument_id_1 = get_polymarket_instrument_id(
            "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
            "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        )
        test_instrument_1 = BinaryOption(
            instrument_id=instrument_id_1,
            raw_symbol=Symbol(f"{instrument_id_1.symbol.value}"),
            outcome="Yes",
            description="Test Polymarket Instrument 1",
            asset_class=AssetClass.ALTERNATIVE,
            currency=USDC,
            price_precision=3,
            price_increment=Price.from_str("0.001"),
            size_precision=2,
            size_increment=Quantity.from_str("0.01"),
            activation_ns=0,
            expiration_ns=0,
            max_quantity=None,
            min_quantity=Quantity.from_str("1"),
            maker_fee=0.0,
            taker_fee=0.0,
            ts_event=0,
            ts_init=0,
        )
        self.cache.add_instrument(test_instrument_1)

        # Mock account state
        balance = AccountBalance(
            total=Money(1000, USDC_POS),
            locked=Money(0, USDC_POS),
            free=Money(1000, USDC_POS),
        )
        self.exec_client.generate_account_state(
            balances=[balance],
            margins=[],
            reported=True,
            ts_event=self.clock.timestamp_ns(),
        )

        return

    def _setup_test_order_with_venue_id(
        self,
        venue_order_id_str: str,
        use_ws_instrument: bool = False,
        price: Price | None = None,
    ) -> tuple[ClientOrderId, VenueOrderId]:
        """
        Create test order in SUBMITTED state and add to cache with venue order ID
        mapping.
        """
        if use_ws_instrument:
            # Use the instrument that matches websocket messages
            instrument_id = get_polymarket_instrument_id(
                "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
                "21742633143463906290569050155826241533067272736897614950488156847949938836455",
            )
        else:
            instrument_id = ELECTION_INSTRUMENT.id

        order = self.strategy.order_factory.limit(
            instrument_id=instrument_id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("5"),
            price=price or Price.from_str("0.513"),
        )

        # Transition to SUBMITTED state (required before ACCEPTED)
        submitted = TestEventStubs.order_submitted(order)
        order.apply(submitted)

        client_order_id = order.client_order_id
        venue_order_id = VenueOrderId(venue_order_id_str)

        self.cache.add_order(order, None)
        self.cache.add_venue_order_id(client_order_id, venue_order_id)

        return client_order_id, venue_order_id

    def test_handle_ws_order_placement_message(self):
        """
        Test handling websocket order placement message.
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
        )

        # Act
        self.exec_client._handle_ws_message(raw_message)

        # Assert - should complete without raising exception
        # The actual processing happens asynchronously in _wait_for_ack_order
        assert True

    def test_handle_ws_order_cancellation_message(self):
        """
        Test handling websocket order cancellation message.
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_cancel.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xc6e99c14f1c7cae9e0538eb2d45a4d8b93ffd743e850edd1502a8c85700be5d3",
        )

        # Act
        self.exec_client._handle_ws_message(raw_message)

        # Assert - should complete without raising exception
        # The actual processing happens asynchronously in _wait_for_ack_order
        assert True

    def test_handle_ws_trade_message_maker_flow(self):
        """
        Test handling websocket trade message for maker order fill.

        This test exercises the full integration path through _handle_ws_message to
        ensure proper message routing, decoding, and trade caching. The fill processing
        happens asynchronously, so this test verifies dispatch rather than the final
        fill state.

        """
        # Arrange - using user_trade1.json which has trader_side: MAKER
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg_data = msgspec.json.decode(raw_message)
        trade_id = msg_data["id"]
        taker_order_id = msg_data["taker_order_id"]

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
            price=Price.from_str("0.518"),
        )

        # Act
        self.exec_client._handle_ws_message(raw_message)

        # Assert
        cache_key = get_polymarket_trades_key(taker_order_id, trade_id)
        cached_trade = self.cache.get(cache_key)

        assert cached_trade is not None, "Trade should be cached after _handle_ws_message"
        assert cached_trade == raw_message, "Cached trade should match original message"

    def test_handle_ws_trade_message_taker_flow(self):
        """
        Test handling websocket trade message for taker order fill.
        """
        # Arrange - using user_trade2.json which has trader_side: TAKER
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade2.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x5b605a0e8e40f3402d3cb3bc19edad6733ed23fbc079d2a09ee399c3487ace81",
            price=Price.from_str("0.52"),
        )

        # Act
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

        # Assert
        assert self.cache.venue_order_id(client_order_id) == venue_order_id

        positions = self.cache.positions()
        assert len(positions) == 1

        position = positions[0]
        assert client_order_id in position.client_order_ids
        assert position.avg_px_open == 0.52
        assert position.entry == OrderSide.BUY
        assert position.quantity.as_double() == 5

    @pytest.mark.asyncio
    async def test_wait_for_ack_order_success(self):
        """
        Test successful order acknowledgment flow.
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
            use_ws_instrument=True,
        )

        # Act
        await self.exec_client._wait_for_ack_order(msg, venue_order_id)

        # Assert - should complete and generate order accepted event
        # Check that the order is still in cache and has the correct venue_order_id mapped
        assert self.cache.venue_order_id(client_order_id) == venue_order_id

    @pytest.mark.asyncio
    async def test_wait_for_ack_order_timeout(self):
        """
        Test order acknowledgment timeout handling.
        """
        # Create exec client with short timeout for fast test
        fast_config = PolymarketExecClientConfig(ack_timeout_secs=0.1)
        fast_exec_client = PolymarketExecutionClient(
            loop=self.loop,
            http_client=self.http_client,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
            instrument_provider=self.provider,
            ws_auth=self.ws_auth,
            config=fast_config,
            name=None,
        )

        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = fast_exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        venue_order_id = VenueOrderId(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
        )

        # Don't add venue_order_id to cache to simulate timeout

        # Act
        await fast_exec_client._wait_for_ack_order(msg, venue_order_id)

        # Assert - should complete without raising exception
        assert True

    @pytest.mark.asyncio
    async def test_wait_for_ack_order_with_event_signal(self):
        """
        Test order acknowledgment via event signal (concurrent notification path).
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        venue_order_id = VenueOrderId(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
        )

        # Create an order and add to cache (but without venue_order_id mapping yet)
        instrument_id_1 = get_polymarket_instrument_id(
            "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
            "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        )
        order = self.strategy.order_factory.limit(
            instrument_id=instrument_id_1,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("5"),
            price=Price.from_str("0.513"),
        )
        client_order_id = order.client_order_id
        self.cache.add_order(order, None)

        # Start waiting in background task
        wait_task = asyncio.create_task(
            self.exec_client._wait_for_ack_order(msg, venue_order_id),
        )

        # Give the wait task time to set up the event
        await asyncio.sleep(0.01)

        # Simulate what _post_signed_order does: add venue_order_id and signal event
        self.cache.add_venue_order_id(client_order_id, venue_order_id)
        event = self.exec_client._ack_events_order.get(venue_order_id)
        if event:
            event.set()

        # Act - wait for the task to complete
        await asyncio.wait_for(wait_task, timeout=1.0)

        # Assert - task should complete successfully without timeout
        assert wait_task.done()
        assert not wait_task.cancelled()
        # Event should have been cleaned up
        assert venue_order_id not in self.exec_client._ack_events_order

    @pytest.mark.asyncio
    async def test_wait_for_ack_trade_success(self):
        """
        Test successful trade acknowledgment flow.
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        # Use a maker order ID from the message (not taker_order_id)
        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
            use_ws_instrument=True,
            price=Price.from_str("0.518"),
        )

        # Act
        await self.exec_client._wait_for_ack_trade(msg, venue_order_id)

        # Assert - should complete and generate order filled event
        # Check that the order is still in cache and trade was processed
        assert self.cache.venue_order_id(client_order_id) == venue_order_id

    @pytest.mark.asyncio
    async def test_wait_for_ack_trade_timeout(self):
        """
        Test trade acknowledgment timeout handling.
        """
        # Create exec client with short timeout for fast test
        fast_config = PolymarketExecClientConfig(ack_timeout_secs=0.1)
        fast_exec_client = PolymarketExecutionClient(
            loop=self.loop,
            http_client=self.http_client,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
            instrument_provider=self.provider,
            ws_auth=self.ws_auth,
            config=fast_config,
            name=None,
        )

        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = fast_exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        # Use a maker order ID from the message (not taker_order_id)
        venue_order_id = VenueOrderId(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
        )

        # Don't add venue_order_id to cache to simulate timeout

        # Act
        await fast_exec_client._wait_for_ack_trade(msg, venue_order_id)

        # Assert - should complete without raising exception
        assert True

    @pytest.mark.asyncio
    async def test_wait_for_ack_trade_with_event_signal(self):
        """
        Test trade acknowledgment via event signal (concurrent notification path).
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        # Use a maker order ID from the message (not taker_order_id)
        venue_order_id = VenueOrderId(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
        )

        # Create an order and add to cache (but without venue_order_id mapping yet)
        instrument_id_1 = get_polymarket_instrument_id(
            "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
            "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        )
        order = self.strategy.order_factory.limit(
            instrument_id=instrument_id_1,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("5"),
            price=Price.from_str("0.518"),
        )
        client_order_id = order.client_order_id
        self.cache.add_order(order, None)

        # Start waiting in background task
        wait_task = asyncio.create_task(
            self.exec_client._wait_for_ack_trade(msg, venue_order_id),
        )

        # Give the wait task time to set up the event
        await asyncio.sleep(0.01)

        # Simulate what _post_signed_order does: add venue_order_id and signal event
        self.cache.add_venue_order_id(client_order_id, venue_order_id)
        event = self.exec_client._ack_events_trade.get(venue_order_id)
        if event:
            event.set()

        # Act - wait for the task to complete
        await asyncio.wait_for(wait_task, timeout=1.0)

        # Assert - task should complete successfully without timeout
        assert wait_task.done()
        assert not wait_task.cancelled()
        # Event should have been cleaned up
        assert venue_order_id not in self.exec_client._ack_events_trade

    def test_order_filled_by_polymarket_order_book_balancing_system(self):
        """
        Polymarket automatically balances the books of token pairs.

        If a user places a Buy order for a Yes token at 0.4, Polymarket will
        automatically place a Sell order for a No token at 0.6 on the user's behalf. If
        another is ready to buy the No token, then Polymarket will mint a pair of tokens
        and sell the Yes and No to the respective user for a net-zero for Polymarket,
        but an increased liquidity for its users.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade3.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x3ad09f225ebe141dfbdb3824f31cb457e8e0301ca4e0a06311e543f5328b9dea",
            use_ws_instrument=True,
        )

        # Act
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

        assert self.cache.venue_order_id(client_order_id) == venue_order_id

        positions = self.cache.positions()

        assert len(positions) == 1

        position = positions[0]

        assert client_order_id in position.client_order_ids
        assert position.avg_px_open == 0.513  # from the json and _setup_test_order_with_venue_id
        assert position.entry == OrderSide.BUY
        assert position.quantity.as_double() == 5

    def test_multiple_user_order_fills_in_same_trade_message_correctly_identified(self):
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade4.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        first_client_order_id, first_venue_order_id = self._setup_test_order_with_venue_id(
            "0x67b598cab933c71389176573822be763192a35a8c37e49999a11d611a5882e7d",
            use_ws_instrument=True,
            price=Price.from_str("0.3"),
        )
        second_client_order_id, second_venue_order_id = self._setup_test_order_with_venue_id(
            "0x3ad09f225ebe141dfbdb3824f31cb457e8e0301ca4e0a06311e543f5328b9dea",
            use_ws_instrument=True,
            price=Price.from_str("0.4"),
        )

        # Act
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

        assert self.cache.venue_order_id(first_client_order_id) == first_venue_order_id
        assert self.cache.venue_order_id(second_client_order_id) == second_venue_order_id

        positions = self.cache.positions()

        assert len(positions) == 1

        position = positions[0]

        assert first_client_order_id in position.client_order_ids
        assert second_client_order_id in position.client_order_ids
        assert position.avg_px_open == 0.35
        assert position.entry == OrderSide.BUY
        assert position.quantity.as_double() == 10

    def test_parse_trades_response_handles_multiple_user_fills(self):
        """
        Test REST API fill parsing with multiple user orders in same trade.

        This tests the _parse_trades_response_object method used by
        generate_fill_reports to ensure it correctly handles multiple user maker orders
        filled by a single taker (same trade_id).

        """
        # Arrange
        raw_ws_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade4.json",
        )
        ws_data = msgspec.json.decode(raw_ws_message)

        # Convert WS format to REST format
        rest_data = {
            k: v
            for k, v in ws_data.items()
            if k not in ["event_type", "type", "timestamp", "trade_owner"]
        }
        rest_data["transaction_hash"] = (
            "0x16527181ac3c2dfb8ab81457aadc40cd9671a2b5f54f511a35b3d60736fb32e3"
        )

        first_client_order_id, first_venue_order_id = self._setup_test_order_with_venue_id(
            "0x67b598cab933c71389176573822be763192a35a8c37e49999a11d611a5882e7d",
            use_ws_instrument=True,
            price=Price.from_str("0.3"),
        )
        second_client_order_id, second_venue_order_id = self._setup_test_order_with_venue_id(
            "0x3ad09f225ebe141dfbdb3824f31cb457e8e0301ca4e0a06311e543f5328b9dea",
            use_ws_instrument=True,
            price=Price.from_str("0.4"),
        )

        # Act
        command = Mock()
        command.instrument_id = None
        command.venue_order_id = None

        parsed_fill_keys: set[tuple[TradeId, VenueOrderId]] = set()
        reports: list = []

        self.exec_client._parse_trades_response_object(
            command=command,
            json_obj=rest_data,
            parsed_fill_keys=parsed_fill_keys,
            reports=reports,
        )

        # Assert
        assert len(reports) == 2
        assert len(parsed_fill_keys) == 2

    def test_parse_trades_response_filters_by_instrument_id(self):
        """
        Ensure instrument-scoped fill queries drop fills for other assets in the same
        market.

        generate_fill_reports fetches trades for the whole market; this verifies that
        _parse_trades_response_object enforces command.instrument_id when multiple maker
        fills with different asset_ids are present.

        """
        market = "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917"
        yes_asset_id = (
            "21742633143463906290569050155826241533067272736897614950488156847949938836455"
        )
        no_asset_id = "1234567890123456789012345678901234567890123456789012345678901234"

        # Add a second instrument for the opposite outcome in the same market
        instrument_id_no = get_polymarket_instrument_id(market, no_asset_id)
        instrument_id_yes = get_polymarket_instrument_id(market, yes_asset_id)
        instrument_yes = self.cache.instrument(instrument_id_yes)
        assert instrument_yes is not None

        instrument_no = BinaryOption(
            instrument_id=instrument_id_no,
            raw_symbol=Symbol(f"{instrument_id_no.symbol.value}"),
            outcome="No",
            description="Test Polymarket Instrument 2",
            asset_class=AssetClass.ALTERNATIVE,
            currency=USDC,
            price_precision=3,
            price_increment=Price.from_str("0.001"),
            size_precision=2,
            size_increment=Quantity.from_str("0.01"),
            activation_ns=0,
            expiration_ns=0,
            max_quantity=None,
            min_quantity=Quantity.from_str("1"),
            maker_fee=0.0,
            taker_fee=0.0,
            ts_event=0,
            ts_init=0,
        )
        self.cache.add_instrument(instrument_no)

        # Orders for each side of the market
        order_yes = self.strategy.order_factory.limit(
            instrument_id=instrument_yes.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("2"),
            price=Price.from_str("0.50"),
        )
        order_no = self.strategy.order_factory.limit(
            instrument_id=instrument_no.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("3"),
            price=Price.from_str("0.45"),
        )

        venue_order_id_yes = VenueOrderId("0xorder_yes")
        venue_order_id_no = VenueOrderId("0xorder_no")

        self.cache.add_order(order_yes, None)
        self.cache.add_venue_order_id(order_yes.client_order_id, venue_order_id_yes)
        self.cache.add_order(order_no, None)
        self.cache.add_venue_order_id(order_no.client_order_id, venue_order_id_no)

        trade_payload = {
            "id": "trade-abc",
            "taker_order_id": "0xtaker",
            "market": market,
            "asset_id": yes_asset_id,
            "side": "BUY",
            "size": "5",
            "fee_rate_bps": "0",
            "price": "0.55",
            "status": "CONFIRMED",
            "match_time": "1710000000",
            "last_update": "1710000001",
            "outcome": "Yes",
            "bucket_index": 0,
            "owner": self.http_client.creds.api_key,
            "maker_address": self.http_client.get_address.return_value,
            "transaction_hash": "0xdeadbeef",
            "maker_orders": [
                {
                    "asset_id": yes_asset_id,
                    "fee_rate_bps": "0",
                    "maker_address": self.http_client.get_address.return_value,
                    "matched_amount": "2",
                    "order_id": venue_order_id_yes.value,
                    "outcome": "Yes",
                    "owner": self.http_client.creds.api_key,
                    "price": "0.50",
                },
                {
                    "asset_id": no_asset_id,
                    "fee_rate_bps": "0",
                    "maker_address": self.http_client.get_address.return_value,
                    "matched_amount": "3",
                    "order_id": venue_order_id_no.value,
                    "outcome": "No",
                    "owner": self.http_client.creds.api_key,
                    "price": "0.45",
                },
            ],
            "trader_side": "MAKER",
        }

        command_yes = Mock()
        command_yes.instrument_id = order_yes.instrument_id
        command_yes.venue_order_id = None
        parsed_fill_keys_yes: set[tuple[TradeId, VenueOrderId]] = set()
        reports_yes: list[FillReport] = []

        self.exec_client._parse_trades_response_object(
            command=command_yes,
            json_obj=trade_payload,
            parsed_fill_keys=parsed_fill_keys_yes,
            reports=reports_yes,
        )

        assert len(reports_yes) == 1
        assert reports_yes[0].instrument_id == order_yes.instrument_id

        command_no = Mock()
        command_no.instrument_id = instrument_no.id
        command_no.venue_order_id = None
        parsed_fill_keys_no: set[tuple[TradeId, VenueOrderId]] = set()
        reports_no: list[FillReport] = []

        self.exec_client._parse_trades_response_object(
            command=command_no,
            json_obj=trade_payload,
            parsed_fill_keys=parsed_fill_keys_no,
            reports=reports_no,
        )

        assert len(reports_no) == 1
        assert reports_no[0].instrument_id == instrument_no.id

    def test_handle_ws_message_invalid_json(self):
        """
        Test handling invalid JSON websocket message.
        """
        # Arrange
        invalid_raw = b'{"invalid": "json"'  # Invalid JSON

        # Act & Assert - should handle gracefully
        self.exec_client._handle_ws_message(invalid_raw)

    def test_handle_ws_message_decode_failure(self):
        """
        Test handling message that fails to decode.
        """
        # Arrange
        unknown_message = msgspec.json.encode([{"unknown_field": "unknown_value"}])

        # Act & Assert - should handle gracefully via exception handling
        self.exec_client._handle_ws_message(unknown_message)

    def test_handle_ws_message_with_logging_enabled(self):
        """
        Test handling websocket message with raw message logging enabled.
        """
        # Arrange
        # Create new config with logging enabled
        config_with_logging = PolymarketExecClientConfig(log_raw_ws_messages=True)

        exec_client_with_logging = PolymarketExecutionClient(
            loop=self.loop,
            http_client=self.http_client,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
            instrument_provider=self.provider,
            ws_auth=self.ws_auth,
            config=config_with_logging,
            name=None,
        )

        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        # Add the correct instrument to cache for this client too
        instrument_id_1 = get_polymarket_instrument_id(
            "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
            "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        )
        test_instrument_1 = BinaryOption(
            instrument_id=instrument_id_1,
            raw_symbol=Symbol(f"{instrument_id_1.symbol.value}"),
            outcome="Yes",
            description="Test Polymarket Instrument 1",
            asset_class=AssetClass.ALTERNATIVE,
            currency=USDC,
            price_precision=3,
            price_increment=Price.from_str("0.001"),
            size_precision=2,
            size_increment=Quantity.from_str("0.01"),
            activation_ns=0,
            expiration_ns=0,
            max_quantity=None,
            min_quantity=Quantity.from_str("1"),
            maker_fee=0.0,
            taker_fee=0.0,
            ts_event=0,
            ts_init=0,
        )
        self.cache.add_instrument(test_instrument_1)

        # Act & Assert - should handle gracefully and log the raw message
        exec_client_with_logging._handle_ws_message(raw_message)

    def test_add_trade_to_cache(self):
        """
        Test adding trade data to cache.
        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        # Act
        self.exec_client._add_trade_to_cache(msg, raw_message)

        # Assert - trade should be added to cache
        expected_key = f"polymarket:trades:{msg.taker_order_id}:{msg.id}"
        cached_value = self.cache.get(expected_key)
        assert cached_value == raw_message

    @pytest.mark.asyncio
    async def test_submit_order_success(self, mocker):
        """
        Test successful order submission.
        """
        # Arrange
        mock_create_order = mocker.patch.object(self.http_client, "create_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        # Mock successful responses
        mock_create_order.return_value = {"signed_order": "mock_signed"}
        mock_post_order.return_value = {"success": True, "orderID": "test_order_id"}

        order = self.strategy.order_factory.limit(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            price=Price.from_str("0.50"),
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert
        mock_create_order.assert_called_once()
        mock_post_order.assert_called_once()

        # Check that venue order ID was cached
        venue_order_id = VenueOrderId("test_order_id")
        cached_client_order_id = self.cache.client_order_id(venue_order_id)
        assert cached_client_order_id == order.client_order_id

    @pytest.mark.asyncio
    async def test_submit_order_failure(self, mocker):
        """
        Test order submission failure handling.
        """
        # Arrange
        mock_create_order = mocker.patch.object(self.http_client, "create_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        # Mock responses
        mock_create_order.return_value = {"signed_order": "mock_signed"}
        mock_post_order.return_value = {"success": False, "error": "Order failed"}

        order = self.strategy.order_factory.limit(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            price=Price.from_str("0.50"),
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert
        mock_create_order.assert_called_once()
        mock_post_order.assert_called_once()

        # Check that order submission was attempted but failed
        # The venue order ID should not be cached since submission failed
        venue_order_id = VenueOrderId("test_order_id")
        cached_client_order_id = self.cache.client_order_id(venue_order_id)
        assert cached_client_order_id is None

    @pytest.mark.asyncio
    async def test_submit_market_buy_without_quote_quantity_denied(self, mocker):
        """
        Market BUY orders must be quote-denominated; verify we emit OrderDenied instead
        of submitting.
        """
        mock_create_market_order = mocker.patch.object(self.http_client, "create_market_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        order = self.strategy.order_factory.market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),  # Base-denominated by default
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        denied_spy = mocker.spy(self.exec_client, "generate_order_denied")

        await self.exec_client._submit_order(submit_order)

        mock_create_market_order.assert_not_called()
        mock_post_order.assert_not_called()
        denied_spy.assert_called_once()
        denied_kwargs = denied_spy.call_args.kwargs
        assert denied_kwargs["client_order_id"] == order.client_order_id
        assert "quote-denominated quantities" in denied_kwargs["reason"]

    @pytest.mark.asyncio
    async def test_submit_market_sell_with_quote_quantity_denied(self, mocker):
        """
        Market SELL orders must specify base quantity; quote-denominated orders are
        denied.
        """
        mock_create_market_order = mocker.patch.object(self.http_client, "create_market_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        order = self.strategy.order_factory.market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_str("10"),
            quote_quantity=True,
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        denied_spy = mocker.spy(self.exec_client, "generate_order_denied")

        await self.exec_client._submit_order(submit_order)

        mock_create_market_order.assert_not_called()
        mock_post_order.assert_not_called()
        denied_spy.assert_called_once()
        denied_kwargs = denied_spy.call_args.kwargs
        assert denied_kwargs["client_order_id"] == order.client_order_id
        assert "base-denominated quantities" in denied_kwargs["reason"]

    def test_handle_unknown_instrument_gracefully(self):
        """
        Test handling websocket messages for unknown instruments gracefully.
        """
        # Arrange - Create a trade message for an instrument not in cache
        raw_message = msgspec.json.encode(
            [
                {
                    "asset_id": "99999999999999999999999999999999999999999999999999999999999999999999999999999",
                    "bucket_index": "0",
                    "event_type": "trade",
                    "fee_rate_bps": "0",
                    "id": "test-trade-id",
                    "last_update": "1748092619",
                    "maker_address": "0xD16896480F5768B7b34696a1F888F36Ae109f3cF",
                    "maker_orders": [],
                    "market": "0xunknownmarket0000000000000000000000000000000000000000000000000000",
                    "match_time": "1748092618",
                    "outcome": "No",
                    "owner": "test-owner",
                    "price": "0.968",
                    "side": "BUY",
                    "size": "100",
                    "status": "MATCHED",
                    "taker_order_id": "0xtest000000000000000000000000000000000000000000000000000000000000",
                    "timestamp": "1748092619162",
                    "trade_owner": "test-owner",
                    "trader_side": "MAKER",
                    "transaction_hash": "0xtest000000000000000000000000000000000000000000000000000000000000",
                    "type": "TRADE",
                },
            ],
        )

        # Act - should handle gracefully without raising exception
        self.exec_client._handle_ws_message(raw_message)

        # Assert - no exception raised, warning logged
        # Test passes if we reach this point without exception

    @pytest.mark.asyncio
    async def test_submit_market_order_success(self, mocker):
        """
        Test successful market order submission using new MarketOrderArgs.
        """
        # Arrange
        mock_create_market_order = mocker.patch.object(self.http_client, "create_market_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        # Mock successful responses
        mock_create_market_order.return_value = {"signed_order": "mock_signed_market"}
        mock_post_order.return_value = {"success": True, "orderID": "test_market_order_id"}

        market_order = self.strategy.order_factory.market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            quote_quantity=True,
            time_in_force=TimeInForce.IOC,  # Test IOC -> FAK mapping
        )
        self.cache.add_order(market_order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=market_order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert
        mock_create_market_order.assert_called_once()
        mock_post_order.assert_called_once()

        # Verify MarketOrderArgs were created correctly
        call_args = mock_create_market_order.call_args[0][0]  # First positional argument
        assert call_args.amount == 10.0
        assert call_args.side == "BUY"
        assert call_args.price == 0  # Market order should have price 0 (calculated server-side)
        assert call_args.order_type == convert_tif_to_polymarket_order_type(TimeInForce.IOC)

        # Check that venue order ID was cached
        venue_order_id = VenueOrderId("test_market_order_id")
        cached_client_order_id = self.cache.client_order_id(venue_order_id)
        assert cached_client_order_id == market_order.client_order_id

    @pytest.mark.asyncio
    async def test_submit_market_order_with_fok(self, mocker):
        """
        Test market order submission with FOK time in force.
        """
        # Arrange
        mock_create_market_order = mocker.patch.object(self.http_client, "create_market_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        # Mock successful responses
        mock_create_market_order.return_value = {"signed_order": "mock_signed_market"}
        mock_post_order.return_value = {"success": True, "orderID": "test_fok_market_order_id"}

        market_order = self.strategy.order_factory.market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_str("5"),
            time_in_force=TimeInForce.FOK,
        )
        self.cache.add_order(market_order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=market_order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert
        mock_create_market_order.assert_called_once()

        # Verify MarketOrderArgs were created correctly
        call_args = mock_create_market_order.call_args[0][0]
        assert call_args.amount == 5.0
        assert call_args.side == "SELL"
        assert call_args.price == 0
        assert call_args.order_type == convert_tif_to_polymarket_order_type(TimeInForce.FOK)

    @pytest.mark.asyncio
    async def test_submit_limit_order_still_works(self, mocker):
        """
        Test that limit orders still work with the refactored submission logic.
        """
        # Arrange
        mock_create_order = mocker.patch.object(self.http_client, "create_order")
        mock_post_order = mocker.patch.object(self.http_client, "post_order")

        # Mock successful responses
        mock_create_order.return_value = {"signed_order": "mock_signed_limit"}
        mock_post_order.return_value = {"success": True, "orderID": "test_limit_order_id"}

        limit_order = self.strategy.order_factory.limit(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            price=Price.from_str("0.50"),
            time_in_force=TimeInForce.GTC,
        )
        self.cache.add_order(limit_order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=limit_order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert
        mock_create_order.assert_called_once()  # Should use create_order, not create_market_order
        mock_post_order.assert_called_once()

        # Verify OrderArgs were created correctly for limit order
        call_args = mock_create_order.call_args[0][0]
        assert call_args.size == 10.0
        assert call_args.side == "BUY"
        assert call_args.price == 0.50  # Limit order should have specific price

    @pytest.mark.asyncio
    async def test_submit_order_invalid_time_in_force(self):
        """
        Test that orders with invalid time in force are rejected.
        """
        # Arrange
        order = self.strategy.order_factory.limit(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            price=Price.from_str("0.50"),
            time_in_force=TimeInForce.DAY,  # Invalid for Polymarket
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert - order should be rejected (no exception, just logged error)
        # Test passes if we reach this point without exception

    @pytest.mark.asyncio
    async def test_submit_order_invalid_order_type(self):
        """
        Test that orders with invalid order types are rejected.
        """
        # Arrange - create a stop market order which is not supported
        order = self.strategy.order_factory.stop_market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            trigger_price=Price.from_str("0.55"),
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert - order should be rejected (no exception, just logged error)
        # Test passes if we reach this point without exception

    def test_order_branching_logic(self):
        """
        Test that _submit_order correctly branches to market vs limit order methods.
        """
        # This is tested implicitly by the other tests, but we can verify
        # the branching logic by checking which method would be called

        # Create mock orders
        market_order = self.strategy.order_factory.market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
        )

        limit_order = self.strategy.order_factory.limit(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            price=Price.from_str("0.50"),
        )

        # Assert order types are correctly identified
        assert market_order.order_type == OrderType.MARKET
        assert limit_order.order_type == OrderType.LIMIT

    @pytest.mark.asyncio
    async def test_maker_fill_preserves_original_order_side(self, mocker):
        """
        Regression test for issue #3126: Maker fill order side inversion when Yes/No
        orders cross.

        When a BUY order for "Yes" is matched against a BUY order for "No"
        (complementary outcomes), the filled event should preserve the original order
        side (BUY), not invert it based on the trade message.

        """
        # Arrange - using maker order ID from user_trade1.json that matches our test wallet
        instrument_id = get_polymarket_instrument_id(
            "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
            "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        )
        order = self.strategy.order_factory.limit(
            instrument_id=instrument_id,
            order_side=OrderSide.BUY,  # Original order is BUY
            quantity=Quantity.from_str("100"),
            price=Price.from_str("0.518"),
        )
        client_order_id = order.client_order_id
        venue_order_id = VenueOrderId(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
        )

        self.cache.add_order(order, None)
        self.cache.add_venue_order_id(client_order_id, venue_order_id)
        filled_spy = mocker.spy(self.exec_client, "generate_order_filled")

        # Act
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )
        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        await self.exec_client._wait_for_ack_trade(msg, venue_order_id)

        # Assert
        filled_spy.assert_called_once()
        call_kwargs = filled_spy.call_args.kwargs

        # ASSERTION: order_side must match the original order (BUY), not be inverted
        assert call_kwargs["order_side"] == OrderSide.BUY, (
            "Maker fill should preserve original order side (BUY), not invert it. "
            "This ensures correct position tracking when Yes/No orders cross-match."
        )
        assert call_kwargs["client_order_id"] == client_order_id
        assert call_kwargs["venue_order_id"] == venue_order_id
        assert call_kwargs["liquidity_side"] == LiquiditySide.MAKER

    @pytest.mark.parametrize(
        ("status", "should_update_account"),
        [
            (PolymarketTradeStatus.MATCHED, False),
            (PolymarketTradeStatus.MINED, True),
            (PolymarketTradeStatus.CONFIRMED, True),
        ],
    )
    def test_account_state_update_only_on_mined_or_confirmed(
        self,
        status: PolymarketTradeStatus,
        should_update_account: bool,
    ):
        """
        Test that account state is only updated when trade status is MINED or CONFIRMED.

        When a trade is MATCHED, it has been sent to the executor service but not yet
        mined on-chain, so the blockchain balance hasn't changed yet. Only when the
        trade is MINED or CONFIRMED should we update the account state from the chain.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        assert raw_message is not None
        msg_data = msgspec.json.decode(raw_message)
        msg_data["status"] = status.value
        modified_message = msgspec.json.encode(msg_data)
        assert modified_message is not None
        msg = self.exec_client._decoder_user_msg.decode(modified_message)

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
            price=Price.from_str("0.518"),
        )

        with patch.object(
            self.exec_client,
            "_update_account_state",
            new_callable=AsyncMock,
        ) as update_mock:
            # Act
            self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

            # Assert
            if should_update_account:
                update_mock.assert_called_once()
            else:
                update_mock.assert_not_called()

    def test_confirmed_trades_kept_in_cache_for_deduplication(self):
        """
        Test that confirmed trades remain in the cache for deduplication.

        Websocket can deliver trades multiple times (reconnects, replays), so confirmed
        trades must stay in the cache to prevent reprocessing duplicate events.

        """
        # Arrange
        confirmed_trade_id = TradeId("confirmed_trade")

        # Act
        self.exec_client._record_processed_trade(
            confirmed_trade_id,
            PolymarketTradeStatus.CONFIRMED,
        )

        # Assert
        assert confirmed_trade_id in self.exec_client._finalized_trades
        assert confirmed_trade_id not in self.exec_client._processed_trades

    def test_processed_trades_limit_enforced(self, monkeypatch):
        """
        Test that the processed trades cache is limited to PROCESSED_TRADES_LIMIT.

        The cache should maintain only the most recent PROCESSED_TRADES_LIMIT trades,
        removing older entries when the limit is exceeded.

        """
        # Arrange
        test_limit = 100
        monkeypatch.setattr(PolymarketExecutionClient, "PROCESSED_TRADES_LIMIT", test_limit)

        # Act
        for i in range(test_limit):
            trade_id = TradeId(f"trade_{i}")
            self.exec_client._record_processed_trade(trade_id, PolymarketTradeStatus.MATCHED)

        overflow_trade_id = TradeId(f"trade_{test_limit}")
        self.exec_client._record_processed_trade(overflow_trade_id, PolymarketTradeStatus.MATCHED)

        # Assert
        assert len(self.exec_client._processed_trades) == test_limit
        assert TradeId("trade_0") not in self.exec_client._processed_trades
        assert overflow_trade_id in self.exec_client._processed_trades
        assert TradeId("trade_1") in self.exec_client._processed_trades

    def test_finalized_trades_limit_enforced(self, monkeypatch):
        """
        Test that the finalized trades cache is limited to PROCESSED_TRADES_LIMIT.

        The cache should maintain only the most recent PROCESSED_TRADES_LIMIT finalized
        trades, removing older entries when the limit is exceeded.

        """
        # Arrange
        test_limit = 100
        monkeypatch.setattr(PolymarketExecutionClient, "PROCESSED_TRADES_LIMIT", test_limit)

        # Act
        for i in range(test_limit):
            trade_id = TradeId(f"trade_{i}")
            self.exec_client._record_processed_trade(trade_id, PolymarketTradeStatus.CONFIRMED)

        overflow_trade_id = TradeId(f"trade_{test_limit}")
        self.exec_client._record_processed_trade(overflow_trade_id, PolymarketTradeStatus.CONFIRMED)

        # Assert
        assert len(self.exec_client._finalized_trades) == test_limit
        assert TradeId("trade_0") not in self.exec_client._finalized_trades
        assert overflow_trade_id in self.exec_client._finalized_trades
        assert TradeId("trade_1") in self.exec_client._finalized_trades

    def test_trade_status_transition_deduplication(self):
        """
        Test MATCHED  MINED  CONFIRMED transition with proper deduplication.

        Verifies that when a trade transitions from MATCHED to MINED/CONFIRMED:
        - The initial MATCHED trade creates a fill
        - The MINED update triggers account refresh but no duplicate fill
        - The CONFIRMED update is skipped (no duplicate fill or account refresh)

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg_data = msgspec.json.decode(raw_message)
        trade_id = TradeId(msg_data["id"])

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
            price=Price.from_str("0.518"),
        )

        # Act - Send MATCHED status
        msg_data["status"] = "MATCHED"
        matched_message = msgspec.json.encode(msg_data)
        msg = self.exec_client._decoder_user_msg.decode(matched_message)

        with patch.object(
            self.exec_client,
            "_update_account_state",
            new_callable=AsyncMock,
        ) as update_mock:
            self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

            # Assert - MATCHED creates fill, stored in _processed_trades, no account update
            assert trade_id in self.exec_client._processed_trades
            assert self.exec_client._processed_trades[trade_id] == PolymarketTradeStatus.MATCHED
            assert trade_id not in self.exec_client._finalized_trades
            update_mock.assert_not_called()

            order = self.cache.order(client_order_id)
            initial_fill_count = len(order.events)

            # Act - Send MINED status (same trade ID)
            msg_data["status"] = "MINED"
            mined_message = msgspec.json.encode(msg_data)
            msg = self.exec_client._decoder_user_msg.decode(mined_message)

            self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

            # Assert - MINED triggers account update, moves to _finalized_trades, no duplicate fill
            assert trade_id in self.exec_client._finalized_trades
            assert trade_id not in self.exec_client._processed_trades
            update_mock.assert_called_once()

            order = self.cache.order(client_order_id)
            assert len(order.events) == initial_fill_count, "No duplicate fill should be created"

            update_mock.reset_mock()

            # Act - Send CONFIRMED status (same trade ID)
            msg_data["status"] = "CONFIRMED"
            confirmed_message = msgspec.json.encode(msg_data)
            msg = self.exec_client._decoder_user_msg.decode(confirmed_message)

            self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

            # Assert - CONFIRMED is skipped (already in _finalized_trades)
            assert trade_id in self.exec_client._finalized_trades
            update_mock.assert_not_called()

            order = self.cache.order(client_order_id)
            assert len(order.events) == initial_fill_count, (
                "No duplicate fill from replayed CONFIRMED"
            )

    def test_replayed_finalized_trade_is_ignored(self):
        """
        Test that replayed MINED/CONFIRMED messages are properly deduplicated.

        Verifies that once a trade reaches finalized status (MINED/CONFIRMED), duplicate
        messages with the same trade ID are ignored completely.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg_data = msgspec.json.decode(raw_message)
        msg_data["status"] = "CONFIRMED"
        trade_id = TradeId(msg_data["id"])

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
            price=Price.from_str("0.518"),
        )

        confirmed_message = msgspec.json.encode(msg_data)
        msg = self.exec_client._decoder_user_msg.decode(confirmed_message)

        # Act - Process initial CONFIRMED message
        with patch.object(
            self.exec_client,
            "_update_account_state",
            new_callable=AsyncMock,
        ) as update_mock:
            self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

            # Assert - Initial message processed
            assert trade_id in self.exec_client._finalized_trades
            update_mock.assert_called_once()

            order = self.cache.order(client_order_id)
            initial_event_count = len(order.events)

            update_mock.reset_mock()

            # Act - Send duplicate CONFIRMED message (websocket replay)
            self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

            # Assert - Duplicate is ignored completely
            assert trade_id in self.exec_client._finalized_trades
            update_mock.assert_not_called()

            order = self.cache.order(client_order_id)
            assert len(order.events) == initial_event_count, (
                "No duplicate events from replayed message"
            )

    @pytest.mark.asyncio
    async def test_generate_fill_reports_with_start_end_datetime(self, mocker):
        # Arrange
        mock_get_trades = mocker.patch.object(self.http_client, "get_trades")
        mock_get_trades.return_value = []

        start_dt = datetime(2024, 1, 15, 10, 30, 0, tzinfo=UTC)
        end_dt = datetime(2024, 1, 15, 12, 0, 0, tzinfo=UTC)

        command = GenerateFillReports(
            instrument_id=None,
            venue_order_id=None,
            start=start_dt,
            end=end_dt,
            command_id=UUID4(),
            ts_init=0,
        )

        # Act
        await self.exec_client.generate_fill_reports(command)

        # Assert
        mock_get_trades.assert_called_once()
        call_kwargs = mock_get_trades.call_args.kwargs
        params = call_kwargs["params"]

        # Verify datetime was correctly converted to integer seconds
        assert params.after == int(start_dt.timestamp())
        assert params.before == int(end_dt.timestamp())

    def test_placement_skipped_when_order_already_canceled(self, mocker):
        """
        Test that PLACEMENT events are skipped when order is already CANCELED.

        This prevents InvalidStateTrigger: CANCELED -> ACCEPTED errors that occur
        when a stale PLACEMENT event arrives after an order was canceled.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
            use_ws_instrument=True,
        )

        # Transition order to CANCELED state
        order = self.cache.order(client_order_id)
        self.exec_client.generate_order_accepted(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            ts_event=self.clock.timestamp_ns(),
        )
        self.exec_client.generate_order_canceled(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            ts_event=self.clock.timestamp_ns(),
        )

        order = self.cache.order(client_order_id)
        assert order.status == OrderStatus.CANCELED

        accepted_spy = mocker.spy(self.exec_client, "generate_order_accepted")

        # Act
        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        self.exec_client._handle_ws_order_msg(msg, wait_for_ack=False)

        # Assert
        accepted_spy.assert_not_called()

    def test_placement_skipped_when_order_already_accepted(self, mocker):
        """
        Test that PLACEMENT events are skipped when order is already ACCEPTED.

        This prevents duplicate OrderAccepted events from stale/replayed messages.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
            use_ws_instrument=True,
        )

        # Transition order to ACCEPTED state
        order = self.cache.order(client_order_id)
        self.exec_client.generate_order_accepted(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            ts_event=self.clock.timestamp_ns(),
        )

        order = self.cache.order(client_order_id)
        assert order.status == OrderStatus.ACCEPTED

        accepted_spy = mocker.spy(self.exec_client, "generate_order_accepted")

        # Act
        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        self.exec_client._handle_ws_order_msg(msg, wait_for_ack=False)

        # Assert
        accepted_spy.assert_not_called()

    def test_cancellation_skipped_when_order_already_canceled(self, mocker):
        """
        Test that CANCELLATION events are skipped when order is already CANCELED.

        This prevents InvalidStateTrigger: CANCELED -> CANCELED errors from
        duplicate cancellation events.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_cancel.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xc6e99c14f1c7cae9e0538eb2d45a4d8b93ffd743e850edd1502a8c85700be5d3",
            use_ws_instrument=True,
        )

        # Transition order to CANCELED state
        order = self.cache.order(client_order_id)
        self.exec_client.generate_order_accepted(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            ts_event=self.clock.timestamp_ns(),
        )
        self.exec_client.generate_order_canceled(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            ts_event=self.clock.timestamp_ns(),
        )

        order = self.cache.order(client_order_id)
        assert order.status == OrderStatus.CANCELED

        canceled_spy = mocker.spy(self.exec_client, "generate_order_canceled")

        # Act
        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        self.exec_client._handle_ws_order_msg(msg, wait_for_ack=False)

        # Assert
        canceled_spy.assert_not_called()

    def test_placement_allowed_when_order_is_submitted(self, mocker):
        """
        Test that PLACEMENT events generate OrderAccepted when order is SUBMITTED.

        This is the normal flow: order is submitted, PLACEMENT event arrives,
        and OrderAccepted is generated.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
            use_ws_instrument=True,
        )

        order = self.cache.order(client_order_id)
        assert order.status == OrderStatus.SUBMITTED

        accepted_spy = mocker.spy(self.exec_client, "generate_order_accepted")

        # Act
        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        self.exec_client._handle_ws_order_msg(msg, wait_for_ack=False)

        # Assert
        accepted_spy.assert_called_once()

    def test_placement_skipped_when_order_partially_filled(self, mocker):
        """
        Test that PLACEMENT events are skipped when order is PARTIALLY_FILLED.

        Once an order has fills, it's already been accepted.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
            use_ws_instrument=True,
        )

        # Transition order to PARTIALLY_FILLED state
        order = self.cache.order(client_order_id)
        self.exec_client.generate_order_accepted(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            ts_event=self.clock.timestamp_ns(),
        )
        self.exec_client.generate_order_filled(
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            venue_position_id=None,
            trade_id=TradeId("test-trade-1"),
            order_side=OrderSide.BUY,
            order_type=OrderType.LIMIT,
            last_qty=Quantity.from_str("2"),
            last_px=Price.from_str("0.513"),
            quote_currency=USDC,
            commission=Money(0, USDC),
            liquidity_side=LiquiditySide.MAKER,
            ts_event=self.clock.timestamp_ns(),
        )

        order = self.cache.order(client_order_id)
        assert order.status == OrderStatus.PARTIALLY_FILLED

        accepted_spy = mocker.spy(self.exec_client, "generate_order_accepted")

        # Act
        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        self.exec_client._handle_ws_order_msg(msg, wait_for_ack=False)

        # Assert
        accepted_spy.assert_not_called()

    @pytest.mark.asyncio
    async def test_duplicate_ack_waiter_reuses_existing_event(self):
        """
        Test that duplicate WebSocket messages reuse existing ack events.

        When a duplicate message arrives for the same venue_order_id before the first
        waiter completes, the second message should reuse the existing event rather than
        overwriting it (which would cause the first waiter to hang).

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="order_placement.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        venue_order_id = VenueOrderId(
            "0x0f76f4dc6eaf3332f4100f2e8a0b4a927351dd64646b7bb12f37df775c657a78",
        )

        # Start first waiter (will create event)
        wait_task1 = asyncio.create_task(
            self.exec_client._wait_for_ack_order(msg, venue_order_id),
        )
        await asyncio.sleep(0.01)

        # Capture the event created by first waiter
        first_event = self.exec_client._ack_events_order.get(venue_order_id)
        assert first_event is not None

        # Start second waiter (should reuse same event)
        wait_task2 = asyncio.create_task(
            self.exec_client._wait_for_ack_order(msg, venue_order_id),
        )
        await asyncio.sleep(0.01)

        # Verify same event object is used
        second_event = self.exec_client._ack_events_order.get(venue_order_id)
        assert second_event is first_event, "Second waiter should reuse existing event"

        # Signal the event - both waiters should complete
        first_event.set()

        await asyncio.wait_for(wait_task1, timeout=1.0)
        await asyncio.wait_for(wait_task2, timeout=1.0)

        assert wait_task1.done()
        assert wait_task2.done()

    def test_multi_order_fill_deduplication(self):
        """
        Test that fills are deduplicated at the (trade_id, venue_order_id) level.

        When a trade contains multiple orders and the message is processed multiple
        times (e.g., from concurrent wait tasks), each fill should only be recorded once
        via the _processed_fills cache.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade4.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))
        trade_id = TradeId(msg.id)

        first_client_order_id, first_venue_order_id = self._setup_test_order_with_venue_id(
            "0x67b598cab933c71389176573822be763192a35a8c37e49999a11d611a5882e7d",
            use_ws_instrument=True,
            price=Price.from_str("0.3"),
        )
        second_client_order_id, second_venue_order_id = self._setup_test_order_with_venue_id(
            "0x3ad09f225ebe141dfbdb3824f31cb457e8e0301ca4e0a06311e543f5328b9dea",
            use_ws_instrument=True,
            price=Price.from_str("0.4"),
        )

        # Act - Process the trade message twice (simulating concurrent wait tasks)
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

        # Assert - Each fill should be recorded exactly once
        assert (trade_id, first_venue_order_id) in self.exec_client._processed_fills
        assert (trade_id, second_venue_order_id) in self.exec_client._processed_fills

        # Verify positions show correct quantities (no duplicates)
        positions = self.cache.positions()
        assert len(positions) == 1
        position = positions[0]
        assert position.quantity.as_double() == 10  # 5 + 5, not 20

        # Verify fills have unique composite trade_ids (not the raw Polymarket trade ID)
        first_order = self.cache.order(first_client_order_id)
        second_order = self.cache.order(second_client_order_id)
        assert len(first_order.trade_ids) == 1
        assert len(second_order.trade_ids) == 1

        first_trade_id = first_order.trade_ids[0]
        second_trade_id = second_order.trade_ids[0]
        assert first_trade_id != second_trade_id
        assert str(first_trade_id).endswith(str(first_venue_order_id)[-8:])
        assert str(second_trade_id).endswith(str(second_venue_order_id)[-8:])

    def test_multi_order_fill_same_price_qty_no_duplicate_error(self):
        """
        Test that two fills with same price/qty don't trigger Position duplicate
        trade_id error.

        Regression test for
        https://github.com/nautechsystems/nautilus_trader/issues/3450
        When multiple orders at the same price get filled by a single market order, Polymarket
        sends one TRADE message. Previously this caused KeyError from Position._check_duplicate_trade_id
        because all fills had the same trade_id. The fix creates composite trade_ids.

        """
        # Arrange
        market = "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917"
        asset_id = "21742633143463906290569050155826241533067272736897614950488156847949938836455"

        # Set up two orders at the SAME price (this is the bug scenario)
        first_client_order_id, first_venue_order_id = self._setup_test_order_with_venue_id(
            "0x6752b79cf729180432f2e35505e8aacb6d1416eb33d1fb31989204a87dd05a0e",
            use_ws_instrument=True,
            price=Price.from_str("0.32"),  # Same price
        )
        second_client_order_id, second_venue_order_id = self._setup_test_order_with_venue_id(
            "0x75ae906908952dac54c9bca307a1206fc87b69e7165051b1b761837c1445f099",
            use_ws_instrument=True,
            price=Price.from_str("0.32"),  # Same price
        )

        trade_payload = {
            "id": "4f424a3c-e347-4c4a-8507-bcb8abbd7765",
            "taker_order_id": "0x97842a562581e0fd8ab7c522c0c7a9d940dd8bc1ae094a53d5b9ae91d00d2855",
            "market": market,
            "asset_id": asset_id,
            "side": "SELL",
            "size": "10",
            "fee_rate_bps": "0",
            "price": "0.32",
            "status": "CONFIRMED",
            "match_time": "1768767988",
            "last_update": "1768768009",
            "outcome": "No",
            "bucket_index": 0,
            "owner": self.http_client.creds.api_key,
            "trade_owner": "092dab0c-74fa-5ba7-4b67-572daeace198",
            "maker_address": self.http_client.get_address.return_value,
            "transaction_hash": "0xabc123",
            "maker_orders": [
                {
                    "asset_id": asset_id,
                    "fee_rate_bps": "0",
                    "maker_address": self.http_client.get_address.return_value,
                    "matched_amount": "5",  # Same qty
                    "order_id": first_venue_order_id.value,
                    "outcome": "No",
                    "outcome_index": 0,
                    "owner": self.http_client.creds.api_key,
                    "price": "0.32",  # Same price
                    "side": "BUY",
                },
                {
                    "asset_id": asset_id,
                    "fee_rate_bps": "0",
                    "maker_address": self.http_client.get_address.return_value,
                    "matched_amount": "5",  # Same qty
                    "order_id": second_venue_order_id.value,
                    "outcome": "No",
                    "outcome_index": 0,
                    "owner": self.http_client.creds.api_key,
                    "price": "0.32",  # Same price
                    "side": "BUY",
                },
            ],
            "trader_side": "MAKER",
            "timestamp": "1768768009893",
            "event_type": "trade",
            "type": "TRADE",
        }

        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(trade_payload))

        # Act - This previously raised KeyError due to duplicate trade_id in position
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=False)

        # Assert - Position should have both fills without error
        positions = self.cache.positions()
        assert len(positions) == 1
        position = positions[0]
        assert position.quantity.as_double() == 10  # 5 + 5

        # Verify the fills have different trade_ids despite same price/qty
        first_order = self.cache.order(first_client_order_id)
        second_order = self.cache.order(second_client_order_id)
        first_trade_id = first_order.trade_ids[0]
        second_trade_id = second_order.trade_ids[0]
        assert first_trade_id != second_trade_id

    def test_parse_trades_response_skips_duplicate_fill_keys(self):
        """
        Test that duplicate (trade_id, venue_order_id) pairs are skipped with warning.

        This can occur if the API returns the same fill multiple times in a response.

        """
        # Arrange
        market = "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917"
        asset_id = "21742633143463906290569050155826241533067272736897614950488156847949938836455"

        client_order_id, venue_order_id = self._setup_test_order_with_venue_id(
            "0xorder_abc",
            use_ws_instrument=True,
            price=Price.from_str("0.50"),
        )

        # Trade payload with the same order appearing twice in maker_orders
        trade_payload = {
            "id": "trade-duplicate-test",
            "taker_order_id": "0xtaker",
            "market": market,
            "asset_id": asset_id,
            "side": "BUY",
            "size": "10",
            "fee_rate_bps": "0",
            "price": "0.50",
            "status": "CONFIRMED",
            "match_time": "1710000000",
            "last_update": "1710000001",
            "outcome": "Yes",
            "bucket_index": 0,
            "owner": self.http_client.creds.api_key,
            "maker_address": self.http_client.get_address.return_value,
            "transaction_hash": "0xdeadbeef",
            "maker_orders": [
                {
                    "asset_id": asset_id,
                    "fee_rate_bps": "0",
                    "maker_address": self.http_client.get_address.return_value,
                    "matched_amount": "5",
                    "order_id": venue_order_id.value,
                    "outcome": "Yes",
                    "owner": self.http_client.creds.api_key,
                    "price": "0.50",
                },
                {
                    "asset_id": asset_id,
                    "fee_rate_bps": "0",
                    "maker_address": self.http_client.get_address.return_value,
                    "matched_amount": "5",
                    "order_id": venue_order_id.value,  # Same order_id (duplicate)
                    "outcome": "Yes",
                    "owner": self.http_client.creds.api_key,
                    "price": "0.50",
                },
            ],
            "trader_side": "MAKER",
        }

        command = Mock()
        command.instrument_id = None
        command.venue_order_id = None

        parsed_fill_keys: set[tuple[TradeId, VenueOrderId]] = set()
        reports: list = []

        # Act
        self.exec_client._parse_trades_response_object(
            command=command,
            json_obj=trade_payload,
            parsed_fill_keys=parsed_fill_keys,
            reports=reports,
        )

        # Assert - Only one fill report despite duplicate entries
        assert len(reports) == 1
        assert len(parsed_fill_keys) == 1

    @pytest.mark.asyncio
    async def test_submit_order_unsupported_type_emits_order_denied(self, mocker):
        """
        Test that unsupported order types emit order_denied event.

        When an order type like STOP_MARKET is submitted, the execution client should
        emit an order_denied event with reason UNSUPPORTED_ORDER_TYPE, not just log an
        error.

        """
        # Arrange
        order = self.strategy.order_factory.stop_market(
            instrument_id=ELECTION_INSTRUMENT.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("10"),
            trigger_price=Price.from_str("0.55"),
        )
        self.cache.add_order(order, None)

        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )

        denied_spy = mocker.spy(self.exec_client, "generate_order_denied")

        # Act
        await self.exec_client._submit_order(submit_order)

        # Assert
        denied_spy.assert_called_once()
        denied_kwargs = denied_spy.call_args.kwargs
        assert denied_kwargs["client_order_id"] == order.client_order_id
        assert denied_kwargs["reason"] == "UNSUPPORTED_ORDER_TYPE"

    @pytest.mark.asyncio
    async def test_duplicate_trade_ack_waiter_reuses_existing_event(self):
        """
        Test that duplicate trade WebSocket messages reuse existing ack events.

        Same as test_duplicate_ack_waiter_reuses_existing_event but for the trade ack
        path (_wait_for_ack_trade) rather than order ack path.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade1.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        # Use a maker order ID from the message (not the taker_order_id)
        venue_order_id = VenueOrderId(
            "0xab679e56242324e15e59cfd488cd0f12e4fd71b153b9bfb57518898b9983145e",
        )

        # Start first waiter (will create event)
        wait_task1 = asyncio.create_task(
            self.exec_client._wait_for_ack_trade(msg, venue_order_id),
        )
        await asyncio.sleep(0.01)

        # Capture the event created by first waiter
        first_event = self.exec_client._ack_events_trade.get(venue_order_id)
        assert first_event is not None

        # Start second waiter (should reuse same event)
        wait_task2 = asyncio.create_task(
            self.exec_client._wait_for_ack_trade(msg, venue_order_id),
        )
        await asyncio.sleep(0.01)

        # Verify same event object is used
        second_event = self.exec_client._ack_events_trade.get(venue_order_id)
        assert second_event is first_event, "Second waiter should reuse existing event"

        # Signal the event - both waiters should complete
        first_event.set()

        await asyncio.wait_for(wait_task1, timeout=1.0)
        await asyncio.wait_for(wait_task2, timeout=1.0)

        assert wait_task1.done()
        assert wait_task2.done()

    @pytest.mark.asyncio
    async def test_multi_order_trade_late_mapping_attribution(self, mocker):
        """
        Test that late-mapped orders in multi-order trades are correctly attributed.

        Scenario: Trade arrives with orders A (already mapped) and B (not yet mapped).
        Order A processes immediately. Order B's wait task must still correctly attribute
        the fill when the mapping arrives, not treat it as unknown.

        """
        # Arrange
        raw_message = pkgutil.get_data(
            package="tests.integration_tests.adapters.polymarket.resources.ws_messages",
            resource="user_trade4.json",
        )

        msg = msgspec.json.decode(raw_message)
        msg = self.exec_client._decoder_user_msg.decode(msgspec.json.encode(msg))

        # Set up order A (already mapped before trade arrives)
        first_client_order_id, first_venue_order_id = self._setup_test_order_with_venue_id(
            "0x67b598cab933c71389176573822be763192a35a8c37e49999a11d611a5882e7d",
            use_ws_instrument=True,
            price=Price.from_str("0.3"),
        )

        # Order B exists but is NOT yet mapped to venue_order_id
        instrument_id = get_polymarket_instrument_id(
            "0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917",
            "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        )
        order_b = self.strategy.order_factory.limit(
            instrument_id=instrument_id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("5"),
            price=Price.from_str("0.4"),
        )
        submitted = TestEventStubs.order_submitted(order_b)
        order_b.apply(submitted)
        self.cache.add_order(order_b, None)
        second_venue_order_id = VenueOrderId(
            "0x3ad09f225ebe141dfbdb3824f31cb457e8e0301ca4e0a06311e543f5328b9dea",
        )

        filled_spy = mocker.spy(self.exec_client, "generate_order_filled")

        # Act - Process the trade with wait_for_ack=True (simulates real WS flow)
        # This will:
        # 1. Process order A immediately (already mapped)
        # 2. Create wait task for order B (not yet mapped)
        self.exec_client._handle_ws_trade_msg(msg, wait_for_ack=True)

        # Allow tasks to start
        await asyncio.sleep(0.05)

        # Now simulate the mapping arriving (e.g., from HTTP response)
        self.cache.add_venue_order_id(order_b.client_order_id, second_venue_order_id)

        # Signal the trade ack event for order B
        event = self.exec_client._ack_events_trade.get(second_venue_order_id)
        if event:
            event.set()

        # Allow processing to complete
        await asyncio.sleep(0.05)

        # Assert - Both orders should have generated fills with proper attribution
        fill_calls = filled_spy.call_args_list
        assert len(fill_calls) == 2, f"Expected 2 fills, got {len(fill_calls)}"

        # Verify both fills have strategy_id (proper attribution, not fill reports)
        for call in fill_calls:
            kwargs = call.kwargs
            assert kwargs["strategy_id"] is not None, (
                "Fill should have strategy_id (proper attribution)"
            )

        # Verify correct client_order_ids
        filled_client_order_ids = {call.kwargs["client_order_id"] for call in fill_calls}
        assert first_client_order_id in filled_client_order_ids
        assert order_b.client_order_id in filled_client_order_ids

    @pytest.mark.asyncio
    async def test_connect_connects_ws_client_with_no_cached_instruments(self, mocker):
        """
        Test that _connect() connects the WebSocket client even with no cached
        instruments.

        Regression test for issue #3403: when NautilusTrader starts with no cached
        instruments, the WebSocket client was never connected because the connection was
        conditional on having market subscriptions.

        """
        # Arrange
        fresh_cache = TestComponentStubs.cache()
        config = PolymarketExecClientConfig()
        exec_client = PolymarketExecutionClient(
            loop=self.loop,
            http_client=self.http_client,
            msgbus=self.msgbus,
            cache=fresh_cache,
            clock=self.clock,
            instrument_provider=self.provider,
            ws_auth=self.ws_auth,
            config=config,
            name=None,
        )

        mock_ws_client = mocker.MagicMock()
        mock_ws_client.is_disconnected.return_value = True
        mock_ws_client.is_connected.return_value = False
        mock_ws_client.market_subscriptions.return_value = []
        mock_ws_client.connect = mocker.AsyncMock()
        exec_client._ws_client = mock_ws_client
        mocker.patch.object(exec_client, "_update_account_state", new=mocker.AsyncMock())
        mocker.patch.object(exec_client, "_await_account_registered", new=mocker.AsyncMock())

        # Act
        await exec_client._connect()

        # Assert
        mock_ws_client.connect.assert_awaited_once()
